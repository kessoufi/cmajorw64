// =================================
// Copyright (c) 2018 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <cmajor/ast/Statement.hpp>
[hpp]#include <cmajor/parser/ParsingContext.hpp>
[cpp]#include <cmajor/parser/Keyword.hpp>
[cpp]#include <cmajor/parser/Expression.hpp>
[cpp]#include <cmajor/parser/TypeExpr.hpp>
[cpp]#include <cmajor/parser/Identifier.hpp>

namespace cmajor.parser
{
    [hpp]using namespace cmajor::ast;

    grammar Statement
    {
        using stdlib.identifier;
        using Keyword.Keyword;
        using Expression.Expression;
        using TypeExpr.TypeExpr;
        using Identifier.Identifier;
        using Expression.ArgumentList;

        Statement(ParsingContext* ctx) : StatementNode*
            ::= LabeledStatement(ctx){ value = LabeledStatement; }
            |   ControlStatement(ctx){ value = ControlStatement; }
            |   ExpressionStatement(ctx){ value = ExpressionStatement; }
            |   AssignmentStatement(ctx){ value = AssignmentStatement; }
            |   ConstructionStatement(ctx){ value = ConstructionStatement; }
            |   DeleteStatement(ctx){ value = DeleteStatement; }
            |   DestroyStatement(ctx){ value = DestroyStatement; }
            |   EmptyStatement(ctx){ value = EmptyStatement; }
            |   ThrowStatement(ctx){ value = ThrowStatement; }
            |   TryStatement(ctx){ value = TryStatement; }
            |   AssertStatement(ctx){ value = AssertStatement; }
            |   ConditionalCompilationStatement(ctx){ value = ConditionalCompilationStatement; }
            ;

        LabelId : std::u32string
            ::= (identifier - Keyword){ value = identifier; }
            ;

        Label(var std::u32string label) : LabelNode*
            ::= (LabelId{ label = LabelId; } ':'){ value = new LabelNode(span, label); }
            ;

        LabeledStatement(ParsingContext* ctx) : StatementNode*
            ::= Label:lbl Statement(ctx):stmt{ stmt->SetLabelNode(lbl); value = stmt; }
            ;

        ControlStatement(ParsingContext* ctx) : StatementNode*
            ::= CompoundStatement(ctx){ value = CompoundStatement; }
            |   ReturnStatement(ctx){ value = ReturnStatement; }
            |   IfStatement(ctx){ value = IfStatement; }
            |   WhileStatement(ctx){ value = WhileStatement; }
            |   DoStatement(ctx){ value = DoStatement; }
            |   RangeForStatement(ctx){ value = RangeForStatement; }
            |   ForStatement(ctx){ value = ForStatement; }
            |   BreakStatement(ctx){ value = BreakStatement; }
            |   ContinueStatement(ctx){ value = ContinueStatement; }
            |   GotoStatement(ctx){ value = GotoStatement; }
            |   SwitchStatement(ctx){ value = SwitchStatement; }
            |   GotoCaseStatement(ctx){ value = GotoCaseStatement; }
            |   GotoDefaultStatement(ctx){ value = GotoDefaultStatement; }
            ;

        CompoundStatement(ParsingContext* ctx) : CompoundStatementNode*
            ::= (   '{'{ value = new CompoundStatementNode(span); value->SetBeginBraceSpan(span); }
                    (Statement(ctx):stmt{ value->AddStatement(stmt); })*
                    '}'!{ value->SetEndBraceSpan(span); }
                ){ value->GetSpan().SetEnd(span.End()); }
            ;

        ReturnStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("return") Expression(ctx)? ';'!){ value = new ReturnStatementNode(span, Expression); }
            ;

        IfStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("if") '(' Expression(ctx) ')' Statement(ctx):thens (keyword("else") Statement(ctx):elses)?){ value = new IfStatementNode(span, Expression, thens, elses); }
            ;

        WhileStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("while") '('! Expression(ctx)! ')'! Statement(ctx)!){ value = new WhileStatementNode(span, Expression, Statement); }
            ;

        DoStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("do") Statement(ctx)! keyword("while")! '('! Expression(ctx)! ')'! ';'!){ value = new DoStatementNode(span, Statement, Expression); }
            ;

        ForStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("for") '(' ForInitStatement(ctx)! Expression(ctx)? ';'! ForLoopStatementExpr(ctx)! ')'! Statement(ctx)!)
            { 
                value = new ForStatementNode(span, ForInitStatement, Expression, ForLoopStatementExpr, Statement);
            }
            ;

        ForInitStatement(ParsingContext* ctx) : StatementNode*
            ::= AssignmentStatement(ctx){ value = AssignmentStatement; }
            |   ConstructionStatement(ctx){ value = ConstructionStatement; }
            |   EmptyStatement(ctx){ value = EmptyStatement; }
            ;

        ForLoopStatementExpr(ParsingContext* ctx) : StatementNode*
            ::= AssignmentStatementExpr(ctx){ value = AssignmentStatementExpr; }
            |   Expression(ctx){ value = new ExpressionStatementNode(span, Expression); }
            |   empty{ value = new EmptyStatementNode(span); }
            ;

        RangeForStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("for") '(' TypeExpr(ctx) Identifier ':' Expression(ctx)! ')'! Statement(ctx)!)
            { 
                value = new RangeForStatementNode(span, TypeExpr, Identifier, Expression, Statement); 
            }
            ;

        BreakStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("break") ';'!){ value = new BreakStatementNode(span); }
            ;

        ContinueStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("continue") ';'!){ value = new ContinueStatementNode(span); }
            ;

        GotoStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("goto") Identifier ';'!){ value = new GotoStatementNode(span, Identifier->Str()); }
            ;

        SwitchStatement(ParsingContext* ctx) : SwitchStatementNode*
            ::= (keyword("switch") '('! Expression(ctx)! ')'!){ value = new SwitchStatementNode(span, Expression); }
                '{'! (CaseStatement(ctx){ value->AddCase(CaseStatement); } | DefaultStatement(ctx){ value->SetDefault(DefaultStatement); })* '}'!
            ;

        CaseStatement(ParsingContext* ctx, var std::unique_ptr<CaseStatementNode> caseS) : CaseStatementNode*
            ::= ((empty{ caseS.reset(new CaseStatementNode(span)); } (keyword("case") Expression(ctx){ caseS->AddCaseExpr(Expression); } ':'!)+){ caseS->GetSpan().SetEnd(span.End()); }
                (Statement(ctx){ caseS->AddStatement(Statement); })*){ value = caseS.release(); }
            ;

        DefaultStatement(ParsingContext* ctx) : DefaultStatementNode*
            ::= (keyword("default") ':'!){ value = new DefaultStatementNode(span); }
                (Statement(ctx){ value->AddStatement(Statement); })*
            ;

        GotoCaseStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("goto") keyword("case") Expression(ctx)! ';'!){ value = new GotoCaseStatementNode(span, Expression); }
            ;

        GotoDefaultStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("goto") keyword("default") ';'!){ value = new GotoDefaultStatementNode(span); }
            ;

        AssignmentStatementExpr(ParsingContext* ctx, var std::unique_ptr<Node> targetExpr) : StatementNode*
            ::= empty{ ctx->PushParsingLvalue(true); } (Expression(ctx):target{ ctx->PopParsingLvalue(); targetExpr.reset(target); } / { ctx->PopParsingLvalue(); } '=' Expression(ctx):source)
            {
                value = new AssignmentStatementNode(span, targetExpr.release(), source);
            }
            ;

        AssignmentStatement(ParsingContext* ctx) : StatementNode*
            ::= (AssignmentStatementExpr(ctx) ';'){ value = AssignmentStatementExpr; value->GetSpan().SetEnd(span.End()); }
            ;

        ConstructionStatement(ParsingContext* ctx) : ConstructionStatementNode*
            ::= TypeExpr(ctx) Identifier!{ value = new ConstructionStatementNode(span, TypeExpr, Identifier); }
                ('=' Expression(ctx)!{ value->AddArgument(Expression); }
                |    '(' ArgumentList(ctx, value)! ')'!
                |   empty
                )
                ';'!{ value->GetSpan().SetEnd(span.End()); }
            ;

        DeleteStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("delete") Expression(ctx)! ';'!){ value = new DeleteStatementNode(span, Expression); }
            ;

        DestroyStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("destroy") Expression(ctx)! ';'!){ value = new DestroyStatementNode(span, Expression); }
            ;

        ExpressionStatement(ParsingContext* ctx, var std::unique_ptr<Node> expr) : StatementNode*
            ::= empty{ ctx->PushParsingExpressionStatement(true); } (Expression(ctx){ expr.reset(Expression); } ';')
                { 
                    ctx->PopParsingExpressionStatement(); 
                    value = new ExpressionStatementNode(span, expr.release()); 
                }
                /
                {
                    ctx->PopParsingExpressionStatement(); 
                }
            ;

        EmptyStatement(ParsingContext* ctx) : StatementNode*
            ::= ';'{ value = new EmptyStatementNode(span); } 
            ;

        ThrowStatement(ParsingContext* ctx) : StatementNode*
            ::= (keyword("throw") Expression(ctx)? ';'!){ value = new ThrowStatementNode(span, Expression); }
            ;

        TryStatement(ParsingContext* ctx) : TryStatementNode*
            ::= keyword("try") CompoundStatement(ctx):tryBlock{ value = new TryStatementNode(span, tryBlock); } 
                (Catch(ctx){ value->AddCatch(Catch); })+
            ;

        Catch(ParsingContext* ctx) : CatchNode*
            ::= (keyword("catch") '('! TypeExpr(ctx)! Identifier? ')'! CompoundStatement(ctx):catchBlock){ value = new CatchNode(span, TypeExpr, Identifier, catchBlock); }
            ;

        AssertStatement(ParsingContext* ctx) : StatementNode*
            ::= ('#' keyword("assert") Expression(ctx)! ';'!){ value = new AssertStatementNode(span, Expression); }
            ;

        ConditionalCompilationStatement(ParsingContext* ctx) : ConditionalCompilationStatementNode*
            ::= '#' keyword("if") '('! ConditionalCompilationExpression:ifExpr{ value = new ConditionalCompilationStatementNode(span, ifExpr); } ')'! (Statement(ctx):ifS{ value->AddIfStatement(ifS); })*
                (
                    '#' keyword("elif") '('! ConditionalCompilationExpression:elifExpr{ value->AddElifExpr(span, elifExpr); } ')'! (Statement(ctx):elifS{ value->AddElifStatement(elifS); })*
                )*
                (
                    '#' keyword("else") (Statement(ctx):elseS{ value->AddElseStatement(span, elseS); })*
                )?
                '#' keyword("endif")!
            ;

        ConditionalCompilationExpression : ConditionalCompilationExpressionNode*
            ::= ConditionalCompilationDisjunction{ value = ConditionalCompilationDisjunction; }
            ;

        ConditionalCompilationDisjunction(var Span s) : ConditionalCompilationExpressionNode*
            ::= ConditionalCompilationConjunction:left{ s = span; value = left; } ("||" ConditionalCompilationConjunction:right{ s.SetEnd(span.End()); value = new ConditionalCompilationDisjunctionNode(s, value, right); })*
            ;

        ConditionalCompilationConjunction(var Span s): ConditionalCompilationExpressionNode*
            ::= ConditionalCompilationPrefix:left{ s = span; value = left; } ("&&" ConditionalCompilationPrefix:right{ s.SetEnd(span.End()); value = new ConditionalCompilationConjunctionNode(s, value, right); })*
            ;

        ConditionalCompilationPrefix : ConditionalCompilationExpressionNode*
            ::= ('!' ConditionalCompilationPrefix:left!){ value = new ConditionalCompilationNotNode(span, left); }
            |   ConditionalCompilationPrimary:right!{ value = right; }
            ;

        ConditionalCompilationPrimary : ConditionalCompilationExpressionNode* 
            ::= Symbol:symb{ value = new ConditionalCompilationPrimaryNode(span, symb); }
            |   '(' ConditionalCompilationExpression:expr{ value = expr; } ')'
            ;

        Symbol : std::u32string
            ::= (identifier - Keyword){ value = std::u32string(matchBegin, matchEnd); }
            ;
    }
}
