using System;
using System.Collections;

namespace cmsx.object
{
    public const ulong undefinedValue = cast<ulong>(-1);

    public enum Segment : byte
    {
        text = 0u, data = 1u, pool = 2u, stack = 3u, unknown = 255u
    }

    public string SegmentStr(Segment segment)
    {
        switch (segment)
        {
            case Segment.text: return "text";
            case Segment.data: return "data";
            case Segment.pool: return "pool";
            case Segment.stack: return "stack";
        }
        return "-";
    }

    public enum Linkage : byte 
    {
        internal_ = 0u, external = 1u, once = 2u, remove = 3u
    }

    public string LinkageStr(Linkage linkage)
    {
        switch (linkage)
        {
            case Linkage.internal_: return "internal";
            case Linkage.external: return "external";
            case Linkage.once: return "once";
            case Linkage.remove: return "remove";
        }
        return "";
    }

    public string ValueFlagStr(Value.Flag flags)
    {
        if (flags == Value.Flag.undefined)
        {
            return "U";
        }
        string s;
        if ((flags & Value.Flag.register) != Value.Flag.undefined)
        {
            s.Append('R');
        }
        if ((flags & Value.Flag.pure) != Value.Flag.undefined)
        {
            s.Append('P');
        }
        if ((flags & Value.Flag.address) != Value.Flag.undefined)
        {
            s.Append('A');
        }
        if ((flags & Value.Flag.function) != Value.Flag.undefined)
        {
            s.Append('F');
        }
        if ((flags & Value.Flag.structure) != Value.Flag.undefined)
        {
            s.Append('S');
        }
        return s;
    }

    public class Value
    {
        public enum Flag : byte
        {
            undefined = 0u,
            register = 1u << 0u,
            pure = 1u << 1u,
            address = 1u << 2u,
            function = 1u << 3u,
            structure = 1u << 4u
        }
        public nothrow Value() : flags(Flag.undefined), value(undefinedValue), symbol(null)
        {
        }
        public nothrow Value(Flag flags_, ulong value_, Symbol* symbol_) : flags(flags_), value(value_), symbol(symbol_)
        {
        }
        public nothrow inline void SetUndefined()
        {
            flags = Flag.undefined;
        }
        public nothrow inline void SetRegister()
        {
            flags = Flag.register;
        }
        public nothrow inline void SetPure()
        {
            flags = cast<Flag>(flags | Flag.pure);
        }
        public nothrow inline void SetAddress()
        {
            flags = cast<Flag>(flags | Flag.address);
        }
        public nothrow inline void SetFunction()
        {
            flags = cast<Flag>(flags | Flag.function);
        }
        public nothrow inline void SetStructure()
        {
            flags = cast<Flag>(flags | Flag.structure);
        }
        public nothrow inline bool GetFlag(Flag flag)
        {
            return (flags & flag) != Flag.undefined;
        }
        public Flag flags;
        public ulong value;
        public Symbol* symbol;
    }

    public string ValueStr(const Value& value)
    {
        string result = Format(ValueFlagStr(value.flags), 5) + " #" + ToHexString(value.value) + " ";
        if (value.flags == Value.Flag.register)
        {
            result.Append(Format("$" + ToString(value.value), 20));
        }
        else
        {
            result.Append(Format(ToString(value.value), 20));
        }
        return result;
    }

    public class Symbol
    {
        public Symbol* Clone()
        {
            Symbol* clone = new Symbol();
            clone->index = -1;
            clone->name = name;
            clone->segment = segment;
            clone->linkage = linkage;
            clone->value = value;
            clone->start = start;
            clone->length = length;
            clone->section = section;
            return clone;
        }
        public int index;
        public string name;
        public string localName;
        public Segment segment;
        public Linkage linkage;
        public Value value;
        public ulong start;
        public ulong length;
        public Section* section;
    }

    public class SymbolTable
    {
        suppress SymbolTable(const SymbolTable&);
        suppress void operator=(const SymbolTable&);
        suppress SymbolTable(SymbolTable&&);
        suppress void operator=(SymbolTable&&);
        public nothrow const List<UniquePtr<Symbol>>& Symbols() const
        {
            return symbols;
        }
        public nothrow const List<UniquePtr<Symbol>>& InternalSymbols() const
        {
            return internalSymbols;
        }
        public Symbol* GetSymbol(int index) const
        {
            return symbols[index].Get();
        }
        public Symbol* GetSymbol(const string& name) const
        {
            Map<string, Symbol*>.ConstIterator it = table.CFind(name);
            if (it != table.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public Symbol* GetSymbolByAddress(ulong absoluteAddress) const
        {
            Map<ulong, Symbol*>.ConstIterator it = addressMap.CFind(absoluteAddress);
            if (it != addressMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public Symbol* GetRegisterSymbol(byte registerNumber) const
        {
            Map<byte, Symbol*>.ConstIterator it = registerMap.CFind(registerNumber);
            if (it != registerMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public void AddSymbol(Symbol* symbol, bool setIndex)
        {
            if (setIndex)
            {
                symbol->index = cast<int>(symbols.Count());
            }
            symbols.Add(UniquePtr<Symbol>(symbol));
            table[symbol->name] = symbol;
            if (symbol->value.flags == Value.Flag.register)
            {
                registerMap[cast<byte>(symbol->value.value)] = symbol;
            }
        }
        public void AddSymbol(Symbol* symbol)
        {
            AddSymbol(symbol, true);
        }
        public void AddSymbolToAddressMap(Symbol* symbol)
        {
            if (symbol->value.GetFlag(Value.Flag.address))
            {
                symbol->start = symbol->section->baseAddress + symbol->value.value;
                addressMap[symbol->start] = symbol;
            }
        }
        public void AddInternalSymbol(Symbol* internalSymbol, bool setIndex)
        {
            if (setIndex)
            {
                internalSymbol->index = cast<int>(internalSymbols.Count());
            }
            #assert(internalSymbol->linkage == Linkage.internal_);
            internalSymbols.Add(UniquePtr<Symbol>(internalSymbol));
            addressMap[internalSymbol->start] = internalSymbol;
        }
        private List<UniquePtr<Symbol>> symbols;
        private List<UniquePtr<Symbol>> internalSymbols;
        private Map<string, Symbol*> table;
        private Map<ulong, Symbol*> addressMap;
        private Map<byte, Symbol*> registerMap;
    }
}
