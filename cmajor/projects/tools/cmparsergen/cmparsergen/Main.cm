using System;
using System.IO;
using System.Text;
using System.Collections;
using Syntax;

internal void AddToLibraryDirectories(const string& libraryPath, List<string>& libraryDirectories)
{
    List<string> dirs = libraryPath.Split(';');
    for (const string& dir : dirs)
    {
        libraryDirectories.Add(dir);
    }
}

internal string Version() 
{
    return "2.0.0";
}

internal void PrintHelp()
{
    Console.WriteLine("Cmajor Parser Generator version " + Version());
    Console.WriteLine();
    Console.WriteLine("Usage: cmparsergen [options] { <project.pp> }");
    Console.WriteLine();
    Console.WriteLine("Read given parser project (.pp) files and ");
    Console.WriteLine("generate Cmajor parser class for each grammar");
    Console.WriteLine("specified in .parser source files.");
    Console.WriteLine();
    Console.WriteLine("Options:");
    Console.WriteLine();
    Console.WriteLine("--force (-F)");
    Console.WriteLine("   Force source code generation although .parser file not changed.");
    Console.WriteLine();
    Console.WriteLine("--verbose (-v)");
    Console.WriteLine("   Generate verbose output.");
    Console.WriteLine();
    Console.WriteLine("--lib <directories> (-L <directories>)");
    Console.WriteLine("   Specify one or more library directories that contain parsing library (.pl) files.");
    Console.WriteLine("   Directories should be separated by ';' character.");
}

internal int main(int argc, const char** argv)
{
    try
    {
        if (argc < 2)
        {
            PrintHelp();
            return 0;
        }
        List<string> projectFiles;
        List<string> libraryDirectories;
        bool prevWasLib = false;
        string cmajorRoot = RtGetEnvironmentVariable("CMAJOR_ROOT");
        if (cmajorRoot.IsEmpty())
        {
            throw Exception("CMAJOR_ROOT environment variable not defined. Please set it to contain /path/to/cmajor directory.");
        }
        string libraryPath = Path.Combine(Path.Combine(cmajorRoot, "system"), "System.Text.Parsing");
        AddToLibraryDirectories(libraryPath, libraryDirectories);
        for (int i = 1; i < argc; ++i)
        {
            string arg = argv[i];
            if (arg.StartsWith("-"))
            {
                if (arg == "--force" || arg == "-F")
                {
                    Syntax.Flags.Instance().SetForceCodeGen();
                }
                else if (arg == "--verbose" || arg == "-v")
                {
                    Syntax.Flags.Instance().SetVerbose();
                }
                else if (arg == "--lib" || arg == "-L")
                {
                    prevWasLib = true;
                }
                else
                {
                    throw Exception("unknown option '" + arg + "'");
                }
            }
            else if (prevWasLib)
            {
                AddToLibraryDirectories(arg, libraryDirectories);
                prevWasLib = false;
            }
            else
            {
                if (arg.EndsWith(".pp"))
                {
                    projectFiles.Add(arg);
                }
                else
                {
                    throw Exception("invalid parser project file extension (not .pp) '" + arg + "'");
                }
            }
        }    
        for (const string& projectFile : projectFiles)
        {
            Generate(projectFile, libraryDirectories);
        }
    }
    catch (const Exception& ex)
    {
        Console.Error() << ex.Message() << endl();
        return 1;
    }
    return 0;
}
