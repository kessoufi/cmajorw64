using System;
using System.Collections;
using System.Text.Parsing;

// this source file has been automatically generated from 'TemplateGrammar.parser' using cmparsergen version 2.0.0.

namespace cppparser
{
    public class TemplateGrammar : System.Text.Parsing.Grammar
    {
        public TemplateGrammar() : this(new ParsingDomain())
        {
        }
        public TemplateGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("TemplateGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class TemplateDeclarationRule : System.Text.Parsing.RuleParser
        {
            public TemplateDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* templateParameterListNonterminalParser = GetNonterminal(ToUtf32("TemplateParameterList"));
                templateParameterListNonterminalParser->SetPre(PreTemplateParameterList);
                NonterminalParser* declarationNonterminalParser = GetNonterminal(ToUtf32("Declaration"));
                declarationNonterminalParser->SetPre(PreDeclaration);
            }
            public void PreTemplateParameterList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PreDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TemplateParameterListRule : System.Text.Parsing.RuleParser
        {
            public TemplateParameterListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TemplateParameterRule : System.Text.Parsing.RuleParser
        {
            public TemplateParameterRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* typeParameterNonterminalParser = GetNonterminal(ToUtf32("TypeParameter"));
                typeParameterNonterminalParser->SetPre(PreTypeParameter);
                NonterminalParser* parameterDeclarationNonterminalParser = GetNonterminal(ToUtf32("ParameterDeclaration"));
                parameterDeclarationNonterminalParser->SetPre(PreParameterDeclaration);
            }
            public void PreTypeParameter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PreParameterDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TypeParameterRule : System.Text.Parsing.RuleParser
        {
            public TypeParameterRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class SimpleTemplateIdRule : System.Text.Parsing.RuleParser
        {
            public SimpleTemplateIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                a1ActionParser->SetFailure(A1ActionFail);
                NonterminalParser* templateArgumentListNonterminalParser = GetNonterminal(ToUtf32("TemplateArgumentList"));
                templateArgumentListNonterminalParser->SetPre(PreTemplateArgumentList);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingTemplateId();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingTemplateId();
            }
            public void A1ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingTemplateId();
            }
            public void PreTemplateArgumentList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TemplateIdRule : System.Text.Parsing.RuleParser
        {
            public TemplateIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* simpleTemplateIdNonterminalParser = GetNonterminal(ToUtf32("SimpleTemplateId"));
                simpleTemplateIdNonterminalParser->SetPre(PreSimpleTemplateId);
            }
            public void PreSimpleTemplateId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TemplateArgumentListRule : System.Text.Parsing.RuleParser
        {
            public TemplateArgumentListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class TemplateArgumentRule : System.Text.Parsing.RuleParser
        {
            public TemplateArgumentRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                NonterminalParser* conditionalExpressionNonterminalParser = GetNonterminal(ToUtf32("ConditionalExpression"));
                conditionalExpressionNonterminalParser->SetPre(PreConditionalExpression);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PreConditionalExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class ExplicitInstantiationRule : System.Text.Parsing.RuleParser
        {
            public ExplicitInstantiationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* declarationNonterminalParser = GetNonterminal(ToUtf32("Declaration"));
                declarationNonterminalParser->SetPre(PreDeclaration);
            }
            public void PreDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public class ExplicitSpecializationRule : System.Text.Parsing.RuleParser
        {
            public ExplicitSpecializationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* declarationNonterminalParser = GetNonterminal(ToUtf32("Declaration"));
                declarationNonterminalParser->SetPre(PreDeclaration);
            }
            public void PreDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx()
                {
                }
                public ParsingContext* ctx;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.FunctionGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.FunctionGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.DeclarationGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.DeclarationGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("cppparser.TypeExprGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new cppparser.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = pd->GetGrammar(ToUtf32("cppparser.IdentifierGrammar"));
            if (grammar3 == null)
            {
                grammar3 = new cppparser.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = pd->GetGrammar(ToUtf32("cppparser.ExpressionGrammar"));
            if (grammar4 == null)
            {
                grammar4 = new cppparser.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar4);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Declaration"), this, ToUtf32("DeclarationGrammar.Declaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ParameterDeclaration"), this, ToUtf32("FunctionGrammar.ParameterDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ConditionalExpression"), this, ToUtf32("ExpressionGrammar.ConditionalExpression")));
            AddRule(new TemplateDeclarationRule(ToUtf32("TemplateDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("template")),
                                new System.Text.Parsing.CharParser('<')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateParameterList"), ToUtf32("TemplateParameterList"), 1)),
                        new System.Text.Parsing.CharParser('>')),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Declaration"), ToUtf32("Declaration"), 1))));
            AddRule(new TemplateParameterListRule(ToUtf32("TemplateParameterList"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("TemplateParameter"), 1),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(','),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("TemplateParameter"), 1)))))));
            AddRule(new TemplateParameterRule(ToUtf32("TemplateParameter"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("TypeParameter"), ToUtf32("TypeParameter"), 1),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("ParameterDeclaration"), ToUtf32("ParameterDeclaration"), 1))));
            AddRule(new TypeParameterRule(ToUtf32("TypeParameter"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("class")),
                                new System.Text.Parsing.KeywordParser(ToUtf32("typename")))),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('='),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1)))))));
            AddRule(new SimpleTemplateIdRule(ToUtf32("SimpleTemplateId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateName"), ToUtf32("TemplateName"), 0),
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.CharParser('<'))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateArgumentList"), ToUtf32("TemplateArgumentList"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.CharParser('>')))));
            AddRule(new TemplateIdRule(ToUtf32("TemplateId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("SimpleTemplateId"), ToUtf32("SimpleTemplateId"), 1)));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("TemplateName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)));
            AddRule(new TemplateArgumentListRule(ToUtf32("TemplateArgumentList"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("TemplateArgument"), 1),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(','),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("TemplateArgument"), 1)))))));
            AddRule(new TemplateArgumentRule(ToUtf32("TemplateArgument"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("ConditionalExpression"), ToUtf32("ConditionalExpression"), 1))));
            AddRule(new ExplicitInstantiationRule(ToUtf32("ExplicitInstantiation"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.KeywordParser(ToUtf32("template")),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Declaration"), ToUtf32("Declaration"), 1))));
            AddRule(new ExplicitSpecializationRule(ToUtf32("ExplicitSpecialization"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("template")),
                            new System.Text.Parsing.CharParser('<')),
                        new System.Text.Parsing.CharParser('>')),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Declaration"), ToUtf32("Declaration"), 1))));
        }
    }
} // cppparser
