using System;
using System.Collections;
using Span = System.Text.Parsing.Span;
using ast;

namespace symbols
{
    public class SymbolTable
    {
        public TypeSymbol* MakeSimpleTypeSymbol(const SimpleTypeNode& simpleTypeNode, const Span& span)
        {
            if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.char_) == SimpleTypeSpecifiers.char_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.char_) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"char");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* charTypeSymbol = new CharTypeSymbol(span);
                    typeMap[charTypeSymbol->name] = charTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(charTypeSymbol));
                    return charTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & (SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.signed)) == (SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.signed) && 
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.signed)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"signed_char");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* signedCharTypeSymbol = new SignedCharTypeSymbol(span);
                    typeMap[signedCharTypeSymbol->name] = signedCharTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(signedCharTypeSymbol));
                    return signedCharTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & (SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.unsigned)) == (SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.unsigned) && 
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.char_ | SimpleTypeSpecifiers.unsigned)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"unsigned_char");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* unsignedCharTypeSymbol = new UnsignedCharTypeSymbol(span);
                    typeMap[unsignedCharTypeSymbol->name] = unsignedCharTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(unsignedCharTypeSymbol));
                    return unsignedCharTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.char16_t) == SimpleTypeSpecifiers.char16_t &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.char16_t) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"char16_t");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* char16TypeSymbol = new Char16TypeSymbol(span);
                    typeMap[char16TypeSymbol->name] = char16TypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(char16TypeSymbol));
                    return char16TypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.char32_t) == SimpleTypeSpecifiers.char32_t &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.char32_t) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"char32_t");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* char32TypeSymbol = new Char32TypeSymbol(span);
                    typeMap[char32TypeSymbol->name] = char32TypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(char32TypeSymbol));
                    return char32TypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.wchar_t) == SimpleTypeSpecifiers.wchar_t &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.wchar_t) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"wchar_t");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* wcharTypeSymbol = new WCharTypeSymbol(span);
                    typeMap[wcharTypeSymbol ->name] = wcharTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(wcharTypeSymbol));
                    return wcharTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.bool_) == SimpleTypeSpecifiers.bool_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.bool_) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"bool");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* boolTypeSymbol = new BoolTypeSymbol(span);
                    typeMap[boolTypeSymbol->name] = boolTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(boolTypeSymbol));
                    return boolTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.short_) == SimpleTypeSpecifiers.short_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.signed | SimpleTypeSpecifiers.short_ | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"short_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* shortIntTypeSymbol = new ShortIntTypeSymbol(span);
                    typeMap[shortIntTypeSymbol->name] = shortIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(shortIntTypeSymbol));
                    return shortIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.short_)) == (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.short_) &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.short_ | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"unsigned_short_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* unsignedShortIntTypeSymbol = new UnsignedShortIntTypeSymbol(span);
                    typeMap[unsignedShortIntTypeSymbol->name] = unsignedShortIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(unsignedShortIntTypeSymbol));
                    return unsignedShortIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.int_ ) == SimpleTypeSpecifiers.int_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.signed | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* intTypeSymbol = new IntTypeSymbol(span);
                    typeMap[intTypeSymbol->name] = intTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(intTypeSymbol));
                    return intTypeSymbol;
                }
            } 
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.long_) == SimpleTypeSpecifiers.long_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.signed | SimpleTypeSpecifiers.long_ | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"long_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* longIntTypeSymbol = new LongIntTypeSymbol(span);
                    typeMap[longIntTypeSymbol->name] = longIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(longIntTypeSymbol));
                    return longIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.unsigned) == SimpleTypeSpecifiers.unsigned &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"usigned_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* unsignedIntTypeSymbol = new UnsignedIntTypeSymbol(span);
                    typeMap[unsignedIntTypeSymbol->name] = unsignedIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(unsignedIntTypeSymbol));
                    return unsignedIntTypeSymbol;
                }
            } 
            else if ((simpleTypeNode.simpleTypeSpecifiers & (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_)) == (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_) &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_ | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"unsigned_long_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* unsignedLongIntTypeSymbol = new UnsignedLongIntTypeSymbol(span);
                    typeMap[unsignedLongIntTypeSymbol->name] = unsignedLongIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(unsignedLongIntTypeSymbol));
                    return unsignedLongIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.long_long) == SimpleTypeSpecifiers.long_long &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.signed | SimpleTypeSpecifiers.long_long | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"long_long_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* longLongIntTypeSymbol = new LongLongIntTypeSymbol(span);
                    typeMap[longLongIntTypeSymbol->name] = longLongIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(longLongIntTypeSymbol));
                    return longLongIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_long)) == (SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_long) &&
                (simpleTypeNode.simpleTypeSpecifiers & ~(SimpleTypeSpecifiers.unsigned | SimpleTypeSpecifiers.long_long | SimpleTypeSpecifiers.int_)) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"unsigned_long_long_int");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* unsignedLongLongIntTypeSymbol = new UnsignedLongLongIntTypeSymbol(span);
                    typeMap[unsignedLongLongIntTypeSymbol->name] = unsignedLongLongIntTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(unsignedLongLongIntTypeSymbol));
                    return unsignedLongLongIntTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.float_) == SimpleTypeSpecifiers.float_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.float_) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"float");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* floatTypeSymbol = new FloatTypeSymbol(span);
                    typeMap[floatTypeSymbol->name] = floatTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(floatTypeSymbol));
                    return floatTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.double_) == SimpleTypeSpecifiers.double_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.double_) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"double");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* doubleTypeSymbol = new DoubleTypeSymbol(span);
                    typeMap[doubleTypeSymbol->name] = doubleTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(doubleTypeSymbol));
                    return doubleTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.void_) == SimpleTypeSpecifiers.void_ &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.void_) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"void");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* voidTypeSymbol = new VoidTypeSymbol(span);
                    typeMap[voidTypeSymbol->name] = voidTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(voidTypeSymbol));
                    return voidTypeSymbol;
                }
            }
            else if ((simpleTypeNode.simpleTypeSpecifiers & SimpleTypeSpecifiers.auto) == SimpleTypeSpecifiers.auto &&
                (simpleTypeNode.simpleTypeSpecifiers & ~SimpleTypeSpecifiers.auto) == SimpleTypeSpecifiers.none)
            {
                HashMap<ustring, TypeSymbol*>.ConstIterator it = typeMap.CFind(u"auto");
                if (it != typeMap.CEnd())
                {
                    return it->second;
                }
                else
                {
                    SimpleTypeSymbol* autoTypeSymbol = new AutoTypeSymbol(span);
                    typeMap[autoTypeSymbol->name] = autoTypeSymbol;
                    types.Add(UniquePtr<TypeSymbol>(autoTypeSymbol));
                    return autoTypeSymbol;
                }
            }
            else
            {
                throw SymbolException("invalid combination of simple type specifiers in simple type '" + ToUtf8(SimpleTypeSpecifierStr(simpleTypeNode.simpleTypeSpecifiers)) + "'", span);
            }
        }
        private HashMap<ustring, TypeSymbol*> typeMap;
        private List<UniquePtr<TypeSymbol>> types;
    }
}
