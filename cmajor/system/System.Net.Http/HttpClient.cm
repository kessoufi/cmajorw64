// =================================
// Copyright (c) 2018 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Net.Sockets;
using System.IO.Compression;

namespace System.Net.Http
{
    public class HttpClient
    {
        public HttpClient(const UriReference& baseAddress_) : 
            baseAddress(baseAddress_), tcpClient(ToUtf8(baseAddress.Host()), ToUtf8(baseAddress.Scheme())), stream(tcpClient.GetStream())
        {
        }
        public HttpStatus Get(const UriReference& uri, HttpHeaderCollection& responseHeaders, SharedPtr<ByteStream>& body)
        {
            HttpHeaderCollection requestHeaders;
            return Get(uri, requestHeaders, responseHeaders, body);
        }
        public HttpStatus Get(const UriReference& uri, HttpHeaderCollection& requestHeaders, HttpHeaderCollection& responseHeaders, SharedPtr<ByteStream>& body)
        {
            UriReference absoluteUri = UriReference.Combine(baseAddress, uri);
            HttpRequest request(absoluteUri, requestHeaders);
            StreamWriter writer(stream);
            request.Write(writer, log);
            HttpStatus status = ReadStartOfMessage(*stream, responseHeaders, log);
            if (status.StatusCode() == statusSuccessOK)
            {
                bool chunked = false;
                HttpHeader* transferEncodingHeader = responseHeaders.GetHeader(u"transfer-encoding");
                if (transferEncodingHeader != null)
                {
                    ustring transferCodingsValue = transferEncodingHeader->CombinedFieldValue();
                    List<HttpFieldValue> transferCodings;
                    HttpParser.Instance().ParseFieldValue(transferCodingsValue, &transferCodings);
                    for (const HttpFieldValue& transferCoding : transferCodings)
                    {
                        if (ToLower(transferCoding.FieldValue()) == u"chunked")
                        {
                            chunked = true;
                        }
                    }
                }
                if (chunked)
                {
                    List<HttpHeader> trailer;
                    SharedPtr<ByteStream> bodyStream = ReadChunkedBody(*stream, trailer);
                    for (const HttpHeader& header : trailer)
                    {
                        responseHeaders.Add(UniquePtr<HttpHeader>(new HttpHeader(header)));
                    }
                    body = bodyStream;
                }
                else
                {
                    body = stream;
                }
            }
            return status;
        }
        public inline nothrow void SetLog(StreamWriter* log_)
        {
            log = log_;
        }
        private UriReference baseAddress;
        private TcpClient tcpClient;
        private SharedPtr<ByteStream> stream;
        private StreamWriter* log;
    }
}
