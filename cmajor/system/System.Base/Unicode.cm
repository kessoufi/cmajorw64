// =================================
// Copyright (c) 2017 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;

namespace System.Unicode
{
    public class UnicodeException : Exception
    {
        public nothrow UnicodeException(const string& message_) : base(message_)
        {
        }
    }
    
    public void ThrowUnicodeException(const string& message)
    {
        throw UnicodeException(message);
    }
    
    public string PathToUnicodeDirectory()
    {
        string cmajorRoot = RtGetEnvironmentVariable("CMAJOR_ROOT");
        if (cmajorRoot.IsEmpty())
        {
            ThrowUnicodeException("CMAJOR_ROOT environment variable not set (set it to /path/to/cmajor directory)");
            return string();
        }
        return Path.Combine(cmajorRoot, "unicode");
    }
    
    public string PathToUcdBinFile()
    {        
        return Path.Combine(PathToUnicodeDirectory(), "cmajor_ucd.bin");
    }
    
    public string MakeCanonicalPropertyName(const string& s)
    {
        string result;
        for (char c : s)
        {
            if (c != '_' && c != ' ' && c != '-')
            {
                result.Append(c);
            }
        }
        return ToLower(result);
    }
    
    public ustring ToUtf32(const string& utf8Str)
    {
        ustring result;
        const char* p = utf8Str.Chars();
        long bytesRemaining = utf8Str.Length();
        while (bytesRemaining > 0)
        {
            char c = *p;
            byte x = cast<byte>(c);
            if ((x & 0x80u) == 0u)
            {
                result.Append(cast<uchar>(cast<uint>(x)));
                --bytesRemaining;
                ++p;
            }
            else if ((x & 0xE0u) == 0xC0u)
            {
                if (bytesRemaining < 2)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                uchar u = cast<uchar>(cast<uint>(0u));
                byte b1 = cast<byte>(p[1]);
                if ((b1 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                byte shift = 0u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b1 & 1u;
                    b1 = b1 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b0 = x;
                for (byte i = 0u; i < 5u; ++i)
                {
                    byte bit = b0 & 1u;
                    b0 = b0 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                result.Append(u);
                bytesRemaining = bytesRemaining - 2;
                p = p + 2;
            }
            else if ((x & 0xF0u) == 0xE0u)
            {
                if (bytesRemaining < 3)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                uchar u = cast<uchar>(cast<uint>(0u));
                byte b2 = cast<byte>(p[2]);
                if ((b2 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                byte shift = 0u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b2 & 1u;
                    b2 = b2 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b1 = cast<byte>(p[1]);
                if ((b1 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b1 & 1u;
                    b1 = b1 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b0 = x;
                for (byte i = 0u; i < 4u; ++i)
                {
                    byte bit = b0 & 1u;
                    b0 = b0 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                result.Append(u);
                bytesRemaining = bytesRemaining - 3;
                p = p + 3;
            }
            else if ((x & 0xF8u) == 0xF0u)
            {
                if (bytesRemaining < 4)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                uchar u = cast<uchar>(cast<uint>(0u));
                byte b3 = cast<byte>(p[3]);
                if ((b3 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                byte shift = 0u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b3 & 1u;
                    b3 = b3 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b2 = cast<byte>(p[2]);
                if ((b2 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b2 & 1u;
                    b2 = b2 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b1 = cast<byte>(p[1]);
                if ((b1 & 0xC0u) != 0x80u)
                {
                    ThrowConversionException("invalid UTF-8 sequence");
                }
                for (byte i = 0u; i < 6u; ++i)
                {
                    byte bit = b1 & 1u;
                    b1 = b1 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                byte b0 = x;
                for (byte i = 0u; i < 3u; ++i)
                {
                    byte bit = b0 & 1u;
                    b0 = b0 >> 1u;
                    u = cast<uchar>(cast<uint>(u) | (cast<uint>(bit) << shift));
                    ++shift;
                }
                result.Append(u);
                bytesRemaining = bytesRemaining - 4;
                p = p + 4;
            }
            else
            {
                ThrowConversionException("invalid UTF-8 sequence");
            }
        }
        return result;
    }
    
    public ustring ToUtf32(const wstring& utf16Str)
    {
        ustring result;
        const wchar* w = utf16Str.Chars();
        long remaining = utf16Str.Length();
        while (remaining > 0)
        {
            wchar w1 = *w++;
            --remaining;
            if (cast<ushort>(w1) < 0xD800u || cast<ushort>(w1) > 0xDFFFu)
            {
                result.Append(w1);
            }
            else
            {
                if (cast<ushort>(w1) < 0xD800u || cast<ushort>(w1) > 0xDBFFu)
                {
                    ThrowConversionException("invalid UTF-16 sequence");
                }
                if (remaining > 0)
                {
                    wchar w2 = *w++;
                    --remaining;
                    if (cast<ushort>(w2) < 0xDC00u || cast<ushort>(w2) > 0xDFFFu)
                    {
                        ThrowConversionException("invalid UTF-16 sequence");
                    }
                    else
                    {
                        uchar uprime = cast<uchar>(((0x03FFu & cast<uint>(w1)) << 10u) | (0x03FFu & cast<uint>(w2)));
                        uchar u = cast<uchar>(cast<uint>(uprime) + 0x10000u);
                        result.Append(u);
                    }
                }
                else
                {
                    ThrowConversionException("invalid UTF-16 sequence");
                }
            } 
        }
        return result;
    }

    public wstring ToUtf16(const ustring& utf32Str)
    {
        wstring result;
        for (uchar u : utf32Str)
        {
            if (cast<uint>(u) > 0x10FFFFu)
            {
                ThrowConversionException("invalid UTF-32 code point");
            }
            if (cast<uint>(u) < 0x10000u)
            {
                if (cast<uint>(u) >= 0xD800 && cast<uint>(u) <= 0xDFFF)
                {
                    ThrowConversionException("invalid UTF-32 code point (reserved for UTF-16)");
                }
                wchar x = cast<wchar>(u);
                result.Append(x);
            }
            else
            {
                uchar uprime = cast<uchar>(cast<uint>(u) - 0x10000u);
                wchar w1 = cast<wchar>(0xD800u);
                wchar w2 = cast<wchar>(0xDC00u);
                for (ushort i = 0u; i < 10u; ++i)
                {
                    ushort bit = cast<ushort>(cast<uint>(uprime) & (cast<uint>(0x1u) << i));
                    w2 = cast<wchar>(cast<ushort>(w2) | bit);
                }
                for (ushort i = 10u; i < 20u; ++i)
                {
                    ushort bit = cast<ushort>((cast<uint>(uprime) & (cast<uint>(0x1u) << i)) >> 10u);
                    w1 = cast<wchar>(cast<ushort>(w1) | bit);
                }
                result.Append(w1);
                result.Append(w2);
            }
        }
        return result;
    }

    public wstring ToUtf16(const string& utf8Str)
    {
        return ToUtf16(ToUtf32(utf8Str));
    }

    public string ToUtf8(const ustring& utf32Str)
    {
        string result;
        for (uchar c : utf32Str)
        {
            uint x = cast<uint>(c);
            if (x < 0x80u)
            {
                result.Append(cast<char>(x & 0x7Fu));
            }
            else if (x < 0x800u)
            {
                byte b1 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b1 = b1 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b0 = 0xC0u;
                for (byte i = 0u; i < 5u; ++i)
                {
                    b0 = b0 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                result.Append(cast<char>(b0));
                result.Append(cast<char>(b1));
            }
            else if (x < 0x10000u)
            {
                byte b2 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b2 = b2 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b1 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b1 = b1 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b0 = 0xE0u;
                for (byte i = 0u; i < 4u; ++i)
                {
                    b0 = b0 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                result.Append(cast<char>(b0));
                result.Append(cast<char>(b1));
                result.Append(cast<char>(b2));
            }
            else if (x < 0x110000u)
            {
                byte b3 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b3 = b3 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b2 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b2 = b2 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b1 = 0x80u;
                for (byte i = 0u; i < 6u; ++i)
                {
                    b1 = b1 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                byte b0 = 0xF0u;
                for (byte i = 0u; i < 3u; ++i)
                {
                    b0 = b0 | (cast<byte>(x & 1u) << i);
                    x = x >> 1u;
                }
                result.Append(cast<char>(b0));
                result.Append(cast<char>(b1));
                result.Append(cast<char>(b2));
                result.Append(cast<char>(b3));
            }
            else
            {
                ThrowConversionException("invalid UTF-32 code point");
            }
        }
        return result;
    }

    public string ToUtf8(const wstring& utf16Str)
    {
        return ToUtf8(ToUtf32(utf16Str));
    }
    
    public enum BinaryPropertyId : byte
    {
        asciiHexDigit,
        alphabetic,
        bidiControl,
        bidiMirrored,
        cased,
        compositionExclusion,
        caseIgnorable,
        fullCompositionExclusion,
        changesWhenCasefolded,
        changesWhenCaseMapped,
        changesWhenNFKCCasefolded,
        changesWhenLowercased,
        changesWhenTitlecased,
        changesWhenUppercased,
        dash,
        deprecated,
        defaultIgnorableCodePoint,
        diacritic,
        extender,
        graphemeBase,
        graphemeExtend,
        graphemeLink,
        hexDigit,
        hyphen,
        idContinue,
        ideographic,
        idStart,
        idsBinaryOperator,
        idsTrinaryOperator,
        joinControl,
        logicalOrderException,
        lowercase,
        math,
        noncharacterCodePoint,
        otherAlphabetic,
        otherDefaultIgnorableCodePoint,
        otherGraphemeExtend,
        otherIdContinue,
        otherIdStart,
        otherLowercase,
        otherMath,
        otherUppercase,
        patternSyntax,
        patternWhiteSpace,
        prependedConcatenationMark,
        quotationMark,
        radical,
        softDotted,
        sentenceterminal,
        terminalPunctuation,
        unifiedIdeograph,
        uppercase,
        variationSelector,
        whiteSpace,
        xidContinue,
        xidStart,
        expandsOnNFC,
        expandsOnNFD,
        expandsOnNFKC,
        expandsOnNFKD
    }
    
    public class BinaryProperty
    {
        public nothrow BinaryProperty(BinaryPropertyId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow BinaryPropertyId Id()
        {
            return id;
        }
        public inline nothrow const string& ShortName()
        {
            return shortName;
        }
        public inline nothrow const string& LongName()
        {
            return longName;
        }
        private BinaryPropertyId id;
        private string shortName;
        private string longName;
    }
    
    public class BinaryPropertyTable
    {
        static BinaryPropertyTable() : instance(new BinaryPropertyTable())
        {
        }
        public static nothrow BinaryPropertyTable& Instance()
        {
            return *instance;
        }
        public nothrow BinaryProperty* GetBinaryProperty(BinaryPropertyId id) const
        {
            Map<BinaryPropertyId, BinaryProperty*>.ConstIterator it = binaryPropertyIdMap.CFind(id);
            if (it != binaryPropertyIdMap.CEnd())
            {
                return it->second;
            }
            return null;
        }
        public BinaryProperty* GetBinaryPropertyByShortName(const string& shortName) const
        {
            Map<string, BinaryProperty*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return it->second;
            }
            return null;
        }
        public BinaryProperty* GetBinaryPropertyByLongName(const string& longName) const
        {
            Map<string, BinaryProperty*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return it->second;
            }
            return null;
        }
        private BinaryPropertyTable() : binaryProperties(), binaryPropertyIdMap(), shortNameMap(), longNameMap()
        {
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.asciiHexDigit, "AHex", "Ascii Hex Digit"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.alphabetic, "Alpha", "Alphabetic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.bidiControl, "Bidi C", "Bidi Control"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.bidiMirrored, "Bidi M", "Bidi Mirrored"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.cased, "Cased", "Cased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.compositionExclusion, "CE", "Composition Exclusion"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.caseIgnorable, "CI", "Case Ignorable"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.fullCompositionExclusion, "Comp Ex", "Full Composition Exclusion"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenCasefolded, "CWCF", "Changes When Casefolded"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenCaseMapped, "CWCM", "Changes When Casemapped"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenNFKCCasefolded, "CWKCF", "Changes When NFKC Casefolded"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenLowercased, "CWL", "Changes When Lowercased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenTitlecased, "CWT", "Changes When Titlecased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenUppercased, "CWU", "Changes When Uppercased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.dash, "Dash", "Dash"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.deprecated, "Dep", "Deprecated"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.defaultIgnorableCodePoint, "DI", "Default Ignorable Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.diacritic, "Dia", "Diacritic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.extender, "Ext", "Extender"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeBase, "Gr Base", "Grapheme Base"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeExtend, "Gr Ext", "Grapheme Extend"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeLink, "Gr Link", "Grapheme Link"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.hexDigit, "Hex", "Hex Digit"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.hyphen, "Hyphen", "Hyphen"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idContinue, "IDC", "ID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.ideographic, "Ideo", "Ideographic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idStart, "IDS", "ID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idsBinaryOperator, "IDSB", "IDS Binary Operator"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idsTrinaryOperator, "IDST", "IDS Trinary Operator"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.joinControl, "Join C", "Join Control"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.logicalOrderException, "LOE", "Logical Order Exception"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.lowercase, "Lower", "Lowercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.math, "Math", "Math"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.noncharacterCodePoint, "NChar", "Noncharacter Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherAlphabetic, "OAlpha", "Other Alphabetic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherDefaultIgnorableCodePoint, "ODI", "Other Default Ignorable Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherGraphemeExtend, "OGr Ext", "Other Grapheme Extend"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherIdContinue, "OIDC", "Other ID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherIdStart, "OIDS", "Other ID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherLowercase, "OLower", "Other Lowercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherMath, "OMath", "Other Math"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherUppercase, "OUpper", "Other Uppercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.patternSyntax, "Pat Syn", "Pattern Syntax"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.patternWhiteSpace, "Pat WS", "Pattern White Space"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.prependedConcatenationMark, "PCM", "Prepended Concatenation Mark"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.quotationMark, "QMark", "Quotation Mark"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.radical, "Radical", "Radical"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.softDotted, "SD", "Soft Dotted"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.sentenceterminal, "STerm", "Sentence Terminal"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.terminalPunctuation, "Term", "Terminal Punctuation"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.unifiedIdeograph, "UIdeo", "Unified Ideograph"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.uppercase, "Upper", "Uppercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.variationSelector, "VS", "Variation Selector"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.whiteSpace, "WSpace", "White Space"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.xidContinue, "XIDC", "XID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.xidStart, "XIDS", "XID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFC, "XO NFC", "Expands On NFC"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFD, "XO NFD", "Expands On NFD"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFKC, "XO NFKC", "Expands On NFKC"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFKD, "XO NFKD", "Expands On NFKD"));
            for (BinaryProperty* binaryProperty : binaryProperties)
            {
                binaryPropertyIdMap[binaryProperty->Id()] = binaryProperty;
                shortNameMap[MakeCanonicalPropertyName(binaryProperty->ShortName())] = binaryProperty;
                longNameMap[MakeCanonicalPropertyName(binaryProperty->LongName())] = binaryProperty;
            }
        }
        public ~BinaryPropertyTable()
        {
            for (BinaryProperty* binaryProperty : binaryProperties)
            {
                delete binaryProperty;
            }
        }
        private List<BinaryProperty*> binaryProperties;
        private Map<BinaryPropertyId, BinaryProperty*> binaryPropertyIdMap;
        private Map<string, BinaryProperty*> shortNameMap;
        private Map<string, BinaryProperty*> longNameMap;
        private static UniquePtr<BinaryPropertyTable> instance;
    }    
    
    public uchar ToLower(uchar c)
    {
        return c; // todo
    }
    
    public uchar ToUpper(uchar c)
    {
        return c; // todo
    }
}
